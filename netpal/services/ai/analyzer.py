"""
AI-powered security finding analyzer (Refactored).

Orchestrates AI provider, context building, and finding enhancement
to generate security findings from scan results.
"""

from typing import List, Optional
import json
from ...models.finding import Finding
from ...models.host import Host
from .provider_factory import ProviderFactory
from .finding_enhancer import FindingEnhancer
from .context_builder import ContextBuilder


class AIAnalyzer:
    """
    Analyzes security evidence and generates findings using AI.
    
    Refactored to use provider pattern with modular components for:
    - Provider selection and initialization
    - Context building from hosts
    - Finding enhancement optimization
    - Response parsing
    
    Attributes:
        config: Configuration dictionary
        ai_type: Selected AI provider type
        prompts: Custom enhancement prompts
        provider: AI provider instance
        enhancer: Finding enhancement optimizer
        context_builder: Context preparation utility
    """
    
    def __init__(self, config: dict):
        """
        Initialize AI analyzer with configuration.
        
        Args:
            config: Configuration dictionary containing AI settings
        """
        self.config = config
        self.ai_type = config.get('ai_type', 'aws')
        
        # Load custom prompts for finding sections
        from ...utils.config_loader import ConfigLoader
        self.prompts = ConfigLoader.load_ai_prompts()
        
        # Create AI provider using factory
        self.provider = ProviderFactory.create_provider(config)
        
        # Initialize supporting components
        if self.provider:
            self.enhancer = FindingEnhancer(self.provider, self.prompts)
            self.context_builder = ContextBuilder()
        else:
            self.enhancer = None
            self.context_builder = None
    
    def is_configured(self) -> bool:
        """
        Check if AI analyzer is properly configured.
        
        Returns:
            True if AI provider initialized and ready
        """
        return self.provider is not None
    
    def analyze_hosts(
        self,
        hosts: List[Host],
        batch_size: int = 5,
        include_evidence: bool = True,
        progress_callback=None,
        enhance_mode: bool = False
    ) -> List[Finding]:
        """
        Analyze hosts and their services to generate security findings.
        
        Args:
            hosts: List of Host objects to analyze
            batch_size: Number of hosts to analyze in each batch
            include_evidence: Whether to read and include proof file contents
            progress_callback: Optional callback function for progress updates
            enhance_mode: If True, use detailed enhancement prompts (optimized to 1 call per finding)
            
        Returns:
            List of Finding objects generated by AI
        """
        if not self.is_configured():
            return []
        
        all_findings = []
        total_batches = (len(hosts) + batch_size - 1) // batch_size
        
        # Process hosts in batches
        for batch_num, i in enumerate(range(0, len(hosts), batch_size), 1):
            batch = hosts[i:i+batch_size]
            
            if progress_callback:
                # Report batch progress
                batch_info = {
                    'batch_num': batch_num,
                    'total_batches': total_batches,
                    'hosts_in_batch': len(batch),
                    'host_ips': [h.ip for h in batch],
                    'total_services': sum(len(h.services) for h in batch)
                }
                progress_callback('batch_start', batch_info)
            
            batch_findings = self._analyze_batch(batch, include_evidence, progress_callback, enhance_mode)
            all_findings.extend(batch_findings)
            
            if progress_callback:
                # Report batch completion
                progress_callback('batch_complete', {
                    'batch_num': batch_num,
                    'findings_count': len(batch_findings)
                })
        
        return all_findings
    
    def _analyze_batch(
        self,
        hosts: List[Host],
        include_evidence: bool = True,
        progress_callback=None,
        enhance_mode: bool = False
    ) -> List[Finding]:
        """
        Analyze a batch of hosts using AI.
        
        Args:
            hosts: List of Host objects in this batch
            include_evidence: Whether to read and include proof file contents
            progress_callback: Optional callback for progress updates
            enhance_mode: If True, use optimized enhancement (1 call vs 5 per finding)
            
        Returns:
            List of Finding objects
        """
        # Prepare context from hosts using context builder
        context = self.context_builder.build_context(hosts, include_evidence)
        
        # Generate prompt and extract screenshots
        prompt, screenshot_paths = self._build_analysis_prompt(context)
        
        # Call AI API with screenshots if available
        try:
            response = self.provider.generate_response(prompt, screenshot_paths)
            
            # Parse findings from response
            findings = self._parse_findings(response, hosts, enhance_mode)
            
            return findings
            
        except Exception as e:
            print(f"Error during AI analysis: {e}")
            return []
    
    def _build_analysis_prompt(self, context: dict) -> tuple:
        """
        Build the initial analysis prompt for AI.
        
        Args:
            context: Host/service context data
            
        Returns:
            Tuple of (prompt string, list of screenshot paths)
        """
        # Extract screenshot paths for vision models
        screenshot_paths = self.context_builder.get_screenshot_paths_from_context(context)
        
        prompt = f"""You are a penetration testing expert analyzing network scan results.
Analyze the following hosts and services to identify security findings.

For each finding, provide:
1. Name: A clear, specific title
2. Severity: Critical, High, Medium, Low, or Info
3. Description: Brief explanation of the vulnerability (2-3 sentences)
4. Impact: Brief security impact statement (1-2 sentences)
5. Remediation: Brief fix recommendations (2-3 bullet points)
6. CVSS Score: If applicable (0.0-10.0)
7. Host IP: The affected host
8. Port: The affected port (if applicable)

Scan Results:
{json.dumps(context, indent=2)}

Focus on:
- Outdated service versions with known vulnerabilities
- Insecure configurations
- Exposed sensitive services
- Missing security controls
- Potential attack vectors

Provide findings in JSON format as an array:
[
  {{
    "name": "Finding name",
    "severity": "High",
    "description": "Brief description",
    "impact": "Brief impact",
    "remediation": "Brief remediation",
    "cvss": 7.5,
    "host_ip": "192.168.1.10",
    "port": 22
  }}
]

Only include genuine security concerns. Return an empty array [] if no significant findings."""
        
        return prompt, screenshot_paths
    
    def _parse_findings(
        self,
        response: str,
        hosts: List[Host],
        enhance_mode: bool = False
    ) -> List[Finding]:
        """
        Parse AI response into Finding objects.
        
        Args:
            response: AI response text
            hosts: Original host objects for reference
            enhance_mode: If True, use optimized enhancement (1 AI call per finding)
            
        Returns:
            List of Finding objects
        """
        findings = []
        
        try:
            # Extract JSON from response
            json_start = response.find('[')
            json_end = response.rfind(']') + 1
            
            if json_start == -1 or json_end == 0:
                # No JSON found
                return findings
            
            json_str = response[json_start:json_end]
            findings_data = json.loads(json_str)
            
            # Create Finding objects
            for finding_dict in findings_data:
                # Find the host by IP
                host_ip = finding_dict.get('host_ip')
                port = finding_dict.get('port')
                host_id = None
                proof_files = []
                
                for host in hosts:
                    if host.ip == host_ip:
                        host_id = host.host_id
                        
                        # Collect proof files for this port (including screenshots)
                        if port:
                            for service in host.services:
                                if service.port == port:
                                    for proof in service.proofs:
                                        result_file = proof.get('result_file')
                                        screenshot_file = proof.get('screenshot_file')
                                        
                                        if result_file:
                                            proof_files.append(result_file)
                                        if screenshot_file:
                                            proof_files.append(screenshot_file)
                                    break
                        break
                
                # Apply enhancement if requested (using optimized 1-call method)
                if enhance_mode and self.enhancer:
                    enhanced_finding = self.enhancer.enhance_finding(finding_dict)
                    finding_dict = enhanced_finding
                
                # Create finding with processed fields
                finding = Finding(
                    host_id=host_id,
                    name=finding_dict.get('name', 'Unknown Finding'),
                    severity=finding_dict.get('severity', 'Info'),
                    description=finding_dict.get('description', ''),
                    port=port,
                    cvss=finding_dict.get('cvss'),
                    cwe=finding_dict.get('cwe'),
                    remediation=finding_dict.get('remediation', ''),
                    impact=finding_dict.get('impact', ''),
                    proof_file=', '.join(proof_files) if proof_files else None
                )
                
                findings.append(finding)
        
        except json.JSONDecodeError as e:
            print(f"Error parsing AI response JSON: {e}")
        except Exception as e:
            print(f"Error creating findings from AI response: {e}")
        
        return findings
    
    def analyze_single_service(
        self,
        host: Host,
        service,
        evidence_content: Optional[str] = None
    ) -> List[Finding]:
        """
        Analyze a single service with optional evidence content.
        
        Args:
            host: Host object
            service: Service object
            evidence_content: Optional evidence file content
            
        Returns:
            List of Finding objects
        """
        if not self.is_configured():
            return []
        
        # Build focused prompt for single service
        context = {
            "host": {
                "ip": host.ip,
                "hostname": host.hostname,
                "os": host.os
            },
            "service": {
                "port": service.port,
                "protocol": service.protocol,
                "service_name": service.service_name,
                "service_version": service.service_version,
                "extrainfo": service.extrainfo
            }
        }
        
        if evidence_content:
            context["evidence"] = evidence_content[:5000]  # Limit evidence size
        
        prompt = f"""Analyze this specific service for security issues:

{json.dumps(context, indent=2)}

Provide findings in JSON format as an array. Only include if there are genuine security concerns."""
        
        try:
            response = self.provider.generate_response(prompt)
            findings = self._parse_findings(response, [host])
            return findings
        except Exception as e:
            print(f"Error analyzing service: {e}")
            return []